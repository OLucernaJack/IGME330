https://www.typescriptlang.org/play?#code/PTAEEkDpQUQDwA4BsCWBjFAXJBPUmcEUA7Ac1ADcBDAJxSoCMkBTAZwCgXNQqAuUYgFcAtg2Y0A3J2bcG-VpjpkpXUGn4MA9ppZViKmaAAm-ACJVMzA92bzFJUgG0AuhNAgexHjRpU8mgDNQBSVSDhAqUABeUAAiADEaZiNY9zAYACUMgHkM9mZo0EdYgGU0bQYcWNd2EGZIBEFWAAsACgBOdoBKNw9MnLz2WrBwKAhhZHQsXFBWlEh6uKpBTE1hC3QqJFxYrvxCB0paeiY2dnLiBVBhZj0HbICAGRQAgpiAFgAmXrAAdxRtqAxKAUBNUBhsHgCAhkjxWDxQAADISicSI86aS7cIzMALLJCYAByVBuhViAFkaNAABqxH6gf6A4GgyYQmbQ2FUeGRREhBzo1SWCZklYA1iQABW8KFCCOSEEzDpaQZAKQQIKLPB0yhhE53KRfLI6JAMsKnWV-Vy0mxFjeAmYv1A5ksrViAAYAIwAWk9Xs+bs9uykICMtrJvt9-sD9MteVDlkKxAdTttrS6GMuOnqSE0pFd8cVABoC3sPGhwQBrfDNAoZQReBgrVZeVbBZgFTA1tSaHGgZhwZhoFYFIbDCCjaDxetoTAoTGgBC0EkycTc4hGUBJTCCGgt3XwtB6dX7GEb1aaMcAcU0PBrVA3eg3sQCKDgqU7bAKAGZQAFp7PMQ4C4riMTRBFOcBuBiVpqCQPYogAPlAOVQAAKlAb4hmA7EwIgzAABVNBKewyEKGCtngpDQGI0JyLVdDPh6LDAO4AJNBodZMEvJIZEOaDSB42cyELARlxEtiaDQXFBG2HBKNAABvdhkOwzdBxQIhmGIbhE2XUAAH5RNJfgcTxGSiWXKQVJY4JFEKREABIFIE9shNIABfUAnKSDBNO09zESstTt13X92Kkv9ZIMpEnJCSBVgAVQQGEaAAYS5Zg03cgBCRFQDsSR2HciQgA

// I. Explicitly typing variables
let a: number;
let b: string;
let c: boolean;
let d: Date;
let e: string[]; // an array of strings
//a = "Fred" // ERROR
e = ["Scooby"];
//e.push(99); // ERROR


// II. Implicitly (i.e. "automatically") typing variables
const meaningOfLife = 42; // will be implicitly typed as a `number`
const defaultName = "Mr. X"; // will be implicitly typed as a `string`
let temp = "utils.js temp value"; // will be implicitly typed as a `string`
//temp = 99 // ERROR
let date = new Date("01-01-2001");
//date = "01-01-2001"; // ERROR
date = new Date()
console.log("date",date) // click the Run button to see the code execute 


// III. Function parameters and return types can be typed too
// Go ahead and "fix" these 3 functions
const doubleIt = (val: number) =>  val * 2;

const doubleItToString = (val: number) =>  String(val * 2);

const formatGreeting = (greeting:string, name:string, forcefully:boolean) => {
  const recipient  = name ? name : defaultName;
  const str = `${greeting} ${recipient}`;
  return forcefully ? `${str.toUpperCase()}!` : str;
};

// IV. Interfaces
// declare the "shape" of an object
// only used at compile time
// used like any other built-in type
interface Car {
  make: string, // required
  model: string, // required
  cylinders?: number, // optional
  equipment?: string[], // optional
  [key:string]: any // and ANY other property is allowed
}

let car1: Car = {make:"Ford", model:"Bronco", cylinders:8, coolness: 11};
//let car2: Car = {make:"Chevy"}; // ERROR


// V. Enumerations
// Enumerable types can be used at runtime
enum Alignment{
  law,
  chaos,
  neutral
}

// OR
// enum Alignment{
//   law = "lawful",
//   chaos = "chaotic",
//   neutral = "neutralty"
// }

interface NPC{
  name: string,
  alignment:  Alignment
}

let arthur: NPC = {name: "Arthur", alignment: Alignment.law };
//let bob: NPC = {name: "Bob", alignment: "Nice" }; // ERROR


// VI. union type
// only used at compile time
// here is a union type of string literals
type RgbColor = "red" | "green" | "blue"; 
let color1: RgbColor = "red";
//let color2: RgbColor = "yellow"; // ERROR

// the union type also lets a value be of more than one type.
const formatScore = (val: string | number) => `Your score is ${val}`;
console.log(formatScore(100));
console.log(formatScore("100"));

// VII. Type Assertions
// Sometimes you will have information about the type of a value that TypeScript canâ€™t know about.
// You will often see these when working with document.querySelector() and HTML elements

const mainCanvas = document.querySelector(".canvas1") as HTMLCanvasElement;

// See the next part for more examples of this!